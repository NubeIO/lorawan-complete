{
    "deviceProfile": {
        "name": "R-IO-OTAA",
        "macVersion": "1.0.2",
        "supportsJoin": true,
        "supportsClassC": true,
        "uplinkInterval": "60s",
        "payloadCodec": "CUSTOM_JS",
        "payloadEncoderScript": "function hexToBytes(hex) {\n    for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n    return bytes;\n}\n// Encode encodes the given object into an array of bytes.\n//  - fPort contains the LoRaWAN fPort number\n//  - obj is an object, e.g. {\"temperature\": 22.5}\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\nfunction Encode(fPort, obj, variables) {\n  return hexToBytes(obj.payload);\n}\n",
        "payloadDecoderScript": "// Chirpstack Decoder function\nfunction Decode(fPort, bytes, variables) {\n  if (fPort == 1) {\n    return DecodeRubix(fPort, bytes, variables)\n  } else {\n    return DecodeModbus(fPort, bytes, variables)\n  }\n}\n\nfunction DecodeModbus(fPort, bytes, variables) {\n  var str = ''\n  for (var i = 0; i < bytes.length; i++) {\n    str += ('0' + (bytes[i] & 0xFF).toString(16)).slice(-2)\n  }\n  return { payload: str }\n}\n\n// RUBIX_DATA_ENCODING\n\n///////////////////////////////////////////////////\n// META DATA KEYS\nvar MDK_TEMP = 1\nvar MDK_RH = 2\nvar MDK_LUX = 3\nvar MDK_MOVEMENT = 4\nvar MDK_COUNTER = 5\n\nvar MDK_DIGITAL = 6\nvar MDK_VOLTAGE_0_10 = 7\nvar MDK_MILLIAMPS_4_20 = 8\n\nvar MDK_OHM = 10\nvar MDK_CO2 = 11\nvar MDK_BATTERY_VOLTAGE = 12\nvar MDK_PUSH_FREQUENCY = 13\n\nvar MDK_RAW = 16\nvar MDK_UO = 17\nvar MDK_UI = 18\nvar MDK_DO = 19\nvar MDK_DI = 20\n\nvar MDK_FIRMWARE_VERSION = 61\nvar MDK_HARDWARE_VERSION = 62\n\nvar MDK_UINT_8 = 30\nvar MDK_INT_8 = 31\nvar MDK_UINT_16 = 32\nvar MDK_INT_16 = 33\nvar MDK_UINT_32 = 34\nvar MDK_INT_32 = 35\nvar MDK_UINT_64 = 36\nvar MDK_INT_64 = 37\nvar MDK_BOOL = 38\nvar MDK_CHAR = 39\n\nvar MDK_FLOAT = 40\nvar MDK_DOUBLE = 41\n\nvar MDK_STRING = 42\n\n///////////////////////////////////////////////////\n// META DATA TYPES\nvar MDT_FIXEDPOINT = 1\nvar MDT_DATAPOINT = 2\nvar MDT_STRING = 3\n\n// struct MetaData{\n//   DataType dataType = fixedPoint\n//   std::string name = \"\"\n//   long lowValue = 0\n//   long highValue = 0\n//   int decimalPoint = 0\n//   int byteCount = 0\n// }\n\nserial_map = {}\nserial_map[MDK_TEMP] = { dataType: MDT_FIXEDPOINT, name: \"temp\", lowValue: -45, highValue: 120, decimalPoint: 2 }\nserial_map[MDK_RH] = { dataType: MDT_FIXEDPOINT, name: \"rh\", lowValue: 0, highValue: 100, decimalPoint: 2 }\nserial_map[MDK_LUX] = { dataType: MDT_FIXEDPOINT, name: \"lux\", lowValue: 0, highValue: 65534, decimalPoint: 0 }\nserial_map[MDK_MOVEMENT] = { dataType: MDT_FIXEDPOINT, name: \"movement\", lowValue: 0, highValue: 1, decimalPoint: 0 }\nserial_map[MDK_COUNTER] = { dataType: MDT_FIXEDPOINT, name: \"count\", lowValue: 0, highValue: 1048576, decimalPoint: 0 }\nserial_map[MDK_DIGITAL] = { dataType: MDT_FIXEDPOINT, name: \"digital\", lowValue: 0, highValue: 1, decimalPoint: 0 }\nserial_map[MDK_VOLTAGE_0_10] = { dataType: MDT_FIXEDPOINT, name: \"0-10v\", lowValue: 0, highValue: 10, decimalPoint: 2 }\nserial_map[MDK_MILLIAMPS_4_20] = { dataType: MDT_FIXEDPOINT, name: \"4-20ma\", lowValue: 4, highValue: 20, decimalPoint: 2 }\nserial_map[MDK_OHM] = { dataType: MDT_FIXEDPOINT, name: \"ohm\", lowValue: 0, highValue: 1048576, decimalPoint: 0 }\nserial_map[MDK_CO2] = { dataType: MDT_FIXEDPOINT, name: \"co2\", lowValue: 0, highValue: 400, decimalPoint: 0 }\nserial_map[MDK_BATTERY_VOLTAGE] = { dataType: MDT_FIXEDPOINT, name: \"battery-voltage\", lowValue: 0, highValue: 6, decimalPoint: 1 }\nserial_map[MDK_PUSH_FREQUENCY] = { dataType: MDT_FIXEDPOINT, name: \"push-frequency\", lowValue: 0, highValue: 2000, decimalPoint: 0 }\nserial_map[MDK_RAW] = { dataType: MDT_FIXEDPOINT, name: \"raw\", lowValue: 0, highValue: 1, decimalPoint: 3 }\nserial_map[MDK_UO] = { dataType: MDT_FIXEDPOINT, name: \"uo\", lowValue: 0, highValue: 1, decimalPoint: 3 }\nserial_map[MDK_UI] = { dataType: MDT_FIXEDPOINT, name: \"ui\", lowValue: 0, highValue: 1, decimalPoint: 3 }\nserial_map[MDK_DO] = { dataType: MDT_FIXEDPOINT, name: \"do\", lowValue: 0, highValue: 1, decimalPoint: 0 }\nserial_map[MDK_DI] = { dataType: MDT_FIXEDPOINT, name: \"di\", lowValue: 0, highValue: 1, decimalPoint: 0 }\nserial_map[MDK_FIRMWARE_VERSION] = { dataType: MDT_FIXEDPOINT, name: \"firmware-version\", lowValue: 0, highValue: 255, decimalPoint: 0 }\nserial_map[MDK_HARDWARE_VERSION] = { dataType: MDT_FIXEDPOINT, name: \"hardware-version\", lowValue: 0, highValue: 255, decimalPoint: 0 }\n\nserial_map[MDK_BOOL] = { dataType: MDT_DATAPOINT, name: \"bool\", lowValue: 0, highValue: 1, decimalPoint: 0 }\nserial_map[MDK_CHAR] = { dataType: MDT_DATAPOINT, name: \"char\", byteCount: 1 }\nserial_map[MDK_UINT_8] = { dataType: MDT_DATAPOINT, name: \"uint_8\", byteCount: 1 }\nserial_map[MDK_INT_8] = { dataType: MDT_DATAPOINT, name: \"int_8\", byteCount: 1 }\nserial_map[MDK_UINT_16] = { dataType: MDT_DATAPOINT, name: \"uint_16\", byteCount: 2 }\nserial_map[MDK_INT_16] = { dataType: MDT_DATAPOINT, name: \"int_16\", byteCount: 2 }\nserial_map[MDK_UINT_32] = { dataType: MDT_DATAPOINT, name: \"uint_32\", byteCount: 4 }\nserial_map[MDK_INT_32] = { dataType: MDT_DATAPOINT, name: \"int_32\", byteCount: 4 }\nserial_map[MDK_UINT_64] = { dataType: MDT_DATAPOINT, name: \"uint_64\", byteCount: 8 }\nserial_map[MDK_INT_64] = { dataType: MDT_DATAPOINT, name: \"int_64\", byteCount: 8 }\nserial_map[MDK_FLOAT] = { dataType: MDT_DATAPOINT, name: \"float\", byteCount: 4 }\nserial_map[MDK_DOUBLE] = { dataType: MDT_DATAPOINT, name: \"double\", byteCount: 8 }\n\nfunction getMetaData(header) {\n  return serial_map[header]\n}\n\nfunction getBitCount(low, high, decimal) {\n  //Calculate the largest possible number\n  var required_size = (high - low) * Math.pow(10, decimal)\n  //Calculate number of bits required to fit number\n  var bit_count = 1\n  while (Math.pow(2, bit_count) < required_size) {\n    bit_count++\n  }\n  return bit_count\n}\n\nfunction getVector(serial_data, bit_count, pos) {\n  // calculate shift required from positioning of data\n  var shift_from_pos = pos % 8\n  // calculate shift required length of data\n  var shift_from_count = (8 - bit_count % 8) % 8\n  // total bytes required for all data, can contain unwanted leading and\n  // trailing data\n  var bytes_required = Math.floor(bit_count / 8)\n  if (bit_count % 8) {\n    bytes_required++\n  }\n  // Checks if extra byte is required\n  if (bit_count + shift_from_pos > bytes_required * 8) {\n    bytes_required++\n  }\n  // Build vector from relative bytes\n  var data_vector = []\n  var byte_location = Math.floor(pos / 8)\n  if (byte_location + bytes_required > serial_data.buffer.length) {\n    data_vector.push(0)\n  } else {\n    for (var i = 0; i < bytes_required; i++) {\n      data_vector.push(serial_data.buffer[byte_location + i])\n    }\n  }\n  // Update bit read position\n  serial_data.read_bit_pos = serial_data.read_bit_pos + bit_count\n  return { data_vector: data_vector, shift_pos: shift_from_pos, bytes_required: bytes_required }\n}\n\nfunction vectorToBits(data_vector, bit_count, shift_pos, bytes_required) {\n  if (bit_count > 32) {\n    // TODO: bitwise operators stop working after 32 bits in JS \n    //  so must use standard arithmetic operators\n    return 0\n  }\n  // Build data_32 from bytes\n  var data_32 = 0\n  var shift_left = (bytes_required * 8) - bit_count - shift_pos\n  for (var i = 0; i < data_vector.length - 1; i++) {\n    data_32 |= data_vector[i]\n    if (i != data_vector.length - 2) {\n      data_32 <<= 8\n    }\n  }\n  // shift forward and add last bits\n  data_32 <<= (8 - shift_left)\n  data_32 |= (data_vector[data_vector.length - 1] >>> shift_left)\n\n  // Mask out leading bits\n  if (bit_count < 32) {\n    data_32 &= Math.pow(2, bit_count) - 1\n  }\n\n  return data_32\n}\n\nfunction bitsToFloat(bits) {\n  var sign = ((bits >>> 31) == 0) ? 1.0 : -1.0;\n  var e = ((bits >>> 23) & 0xff);\n  var m = (e == 0) ? (bits & 0x7fffff) << 1 : (bits & 0x7fffff) | 0x800000;\n  return sign * m * Math.pow(2, e - 150);\n}\n\nfunction hasPositionalData(serial_data) {\n  return serial_data.buffer[0] & 1;\n}\n\nfunction DecodeRubix(fPort, bytes, variables) {\n  var HEADER_BIT_COUNT = 6\n  var payload = {}\n  var shift_pos = 0\n  var bytes_required = 0\n  var position = 1\n  var serial_data = {\n    buffer: bytes,\n    read_bit_pos: 8\n  }\n\n  while (serial_data.read_bit_pos < (serial_data.buffer.length * 8) - HEADER_BIT_COUNT) {\n    // Get header vector from buffer\n    if (hasPositionalData(serial_data)) {\n      var position_vector_dict = getVector(serial_data, 8, serial_data.read_bit_pos);\n      var position_vector = position_vector_dict.data_vector\n      shift_pos = position_vector_dict.shift_pos\n      bytes_required = position_vector_dict.bytes_required\n      position = vectorToBits(position_vector, 8, shift_pos, bytes_required);\n    }\n    var header_vector_dict = getVector(serial_data, HEADER_BIT_COUNT, serial_data.read_bit_pos)\n    var header_vector = header_vector_dict.data_vector\n    shift_pos = header_vector_dict.shift_pos\n    bytes_required = header_vector_dict.bytes_required\n    // Convert header vector to BIT_TYPE\n    var header = vectorToBits(header_vector, HEADER_BIT_COUNT, shift_pos, bytes_required)\n\n    // If no header EOF\n    if (!header) {\n      break\n    }\n\n    // Get meta data\n    var meta_data = getMetaData(header)\n    var bit_count = 0\n    var data_bits = 0\n    var data_vector = []\n\n    if (meta_data.dataType == MDT_FIXEDPOINT) {\n      bit_count = getBitCount(meta_data.lowValue, meta_data.highValue, meta_data.decimalPoint)\n      // Build vector from buffer\n      data_vector_dict = getVector(serial_data, bit_count, serial_data.read_bit_pos)\n      data_vector = data_vector_dict.data_vector\n      shift_pos = data_vector_dict.shift_pos\n      bytes_required = data_vector_dict.bytes_required\n      // Convert vector to BIT_TYPE\n      data_bits = vectorToBits(data_vector, bit_count, shift_pos, bytes_required)\n      // Convert BIT_TYPE to fixed point float\n      data_bits = (data_bits / Math.pow(10, meta_data.decimalPoint)) + meta_data.lowValue\n    }\n    else if (meta_data.dataType == MDT_DATAPOINT) {\n      bit_count = meta_data.byteCount * 8\n      // Build vector from buffer\n      data_vector_dict = getVector(serial_data, bit_count, serial_data.read_bit_pos)\n      data_vector = data_vector_dict.data_vector\n      shift_pos = data_vector_dict.shift_pos\n      bytes_required = data_vector_dict.bytes_required\n      // Convert vector to BIT_TYPE\n      data_bits =\n        vectorToBits(data_vector, bit_count, shift_pos, bytes_required)\n      // Convert BIT_TYPE to datatype\n      switch (header) {\n        case MDK_CHAR:\n          data_bits = String.fromCharCode(data_bits)\n          break\n        case MDK_UINT_8:\n        case MDK_UINT_16:\n        case MDK_UINT_32:\n          data_bits >>>= 0\n          break\n        case MDK_UINT_64:\n          data_bits >>>= 0\n          break\n        case MDK_INT_8:\n          data_bits = data_bits << 24 >> 24\n          break\n        case MDK_INT_16:\n          data_bits = data_bits << 16 >> 16\n          break\n        case MDK_INT_32:\n          break\n        case MDK_INT_64:\n          break\n        case MDK_FLOAT:\n          // TODO: Note: fails on small rounding like 0.01098.. to 0.011\n          data_bits = Math.round(bitsToFloat(data_bits) * 100000) / 100000\n          break\n        // case MetaDataKey::MDK_DOUBLE:\n        //     break\n        default:\n          return false\n      }\n    }\n    payload[meta_data.name + '-' + (position++)] = data_bits;\n  }\n  return { payload: payload }\n}\n"
    }
}
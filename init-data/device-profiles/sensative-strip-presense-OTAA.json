{
    "deviceProfile": {
        "name": "Sensative-Strip-Presense-OTAA",
        "macVersion": "1.0.3",
        "regParamsRevision": "A",
        "supportsJoin": true,
        "payloadCodec": "CUSTOM_JS",
        "payloadEncoderScript": "",
        "payloadDecoderScript": "// Decode decodes an array of bytes into an object.\n//  - fPort contains the LoRaWAN fPort number\n//  - bytes is an array of bytes, e.g. [225, 230, 255, 0]\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\n// The function must return an object, e.g. {\"temperature\": 22.5}\nfunction Decode(fPort, bytes, variables) {\n  var port = fPort;\n  function decodeFrame(type, target) {\n    switch(type & 0x7f) {\n      case 0:\n        target.emptyFrame = {};\n        break;\n      case 1: // Battery 1byte 0-100%\n        target.battery = {};\n        target.battery = bytes[pos++];\n        break;\n      case 2: // TempReport 2bytes 0.1degree C\n        target.temperature = {}; // celcius 0.1 precision\n        target.temperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n        break;\n      case 3:\n        // Temp alarm\n        target.tempAlarm = {};  // sends alarm after >x<\n        target.tempAlarm.highAlarm = !!(bytes[pos] & 0x01); // boolean\n        target.tempAlarm.lowAlarm = !!(bytes[pos] & 0x02);  // boolean\n        pos++;\n        break;\n      case 4: // AvgTempReport 2bytes 0.1degree C\n        target.averageTemperature = {};\n        target.averageTemperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n        break;\n      case 5:\n        // AvgTemp alarm\n        target.avgTempAlarm = {}; // sends alarm after >x<\n        target.avgTempAlarm.highAlarm = !!(bytes[pos] & 0x01); // boolean\n        target.avgTempAlarm.lowAlarm = !!(bytes[pos] & 0x02);  // boolean\n        pos++;\n        break;\n      case 6: // Humidity 1byte 0-100% in 0.5%\n        target.humidity = {};\n        target.humidity.value = bytes[pos++] / 2; // relativeHumidity percent 0,5\n        break;\n      case 7: // Lux 2bytes 0-65535lux\n        target.lux = {};\n        target.lux.value = ((bytes[pos++] << 8) | bytes[pos++]); // you can  the lux range between two sets (lux1 and 2)\n        break;\n      case 8: // Lux 2bytes 0-65535lux\n        target.lux2 = {};\n        target.lux2.value = ((bytes[pos++] << 8) | bytes[pos++]);\n        break;\n      case 9: // DoorSwitch 1bytes binary\n        target.door = {};\n        target.door.value = !!bytes[pos++]; // true = door open, false = door closed\n        break;\n      case 10: // DoorAlarm 1bytes binary\n        target.doorAlarm = {};\n        target.doorAlarm.value = !!bytes[pos++]; // boolean true = alarm\n        break;\n      case 11: // TamperReport 1bytes binary\n        target.tamperReport = {};\n        target.tamperReport.value = !!bytes[pos++]; // should never trigger anymore\n        break;\n      case 12: // TamperAlarm 1bytes binary\n        target.tamperAlarm = {};\n        target.tamperAlarm.value = !!bytes[pos++]; // should never trigger anymore\n        break;\n      case 13: // Flood 1byte 0-100%\n        target.flood = {};\n        target.flood.value = bytes[pos++]; // percentage, relative wetness\n        break;\n      case 14: // FloodAlarm 1bytes binary\n        target.floodAlarm = {};\n        target.floodAlarm.value = !!bytes[pos++]; // boolean, after >x<\n        break;\n      case 15: // FoilAlarm 1bytes binary\n        target.foilAlarm = {};\n        target.foilAlarm.value = !!bytes[pos++]; // should never trigger anymore\n        break;\n    case 16: // UserSwitch1Alarm, 1 byte digital\n        target.userSwitch1Alarm = {};\n        target.userSwitch1Alarm.value = !!bytes[pos++];\n        break;\n    case 17: // DoorCountReport, 2 byte analog\n        target.doorCount = {};\n        target.doorCount.value = ((bytes[pos++] << 8) | bytes[pos++]);\n        break;\n    case 18: // PresenceReport, 1 byte digital\n        target.presence = {};\n        target.presence.value = !!bytes[pos++];\n        break;\n    case 19: // IRProximityReport\n        target.IRproximity = {};\n        target.IRproximity.value = ((bytes[pos++] << 8) | bytes[pos++]);\n        break;\n    case 20: // IRCloseProximityReport, low power\n        target.IRcloseproximity = {};\n        target.IRcloseproximity.value = ((bytes[pos++] << 8) | bytes[pos++]);\n        break;\n    case 21: // CloseProximityAlarm, something very close to presence sensor\n        target.closeProximityAlarm = {};\n        target.closeProximityAlarm.value = !!bytes[pos++];\n        break;\n    case 22: // DisinfectAlarm\n        target.disinfectAlarm = {};\n        target.disinfectAlarm.value = bytes[pos++];\n        if (target.disinfectAlarm.value == 0) target.disinfectAlarm.state='dirty';\n        if (target.disinfectAlarm.value == 1) target.disinfectAlarm.state='occupied';\n        if (target.disinfectAlarm.value == 2) target.disinfectAlarm.state='cleaning';\n        if (target.disinfectAlarm.value == 3) target.disinfectAlarm.state='clean';\n        break;\n    case 80:\n        target.humidity = {};\n        target.humidity.value = bytes[pos++] / 2;\n        target.temperature = {};\n        target.temperature = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n        break;\n      case 81:\n        target.humidity = {};\n        target.humidity.value = bytes[pos++] / 2;\n        target.averageTemperature = {};\n        target.averageTemperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n        break;\n      case 82:\n        target.door = {};\n        target.door.value = !!bytes[pos++]; // true = door open, false = door closed\n        target.temperature = {};\n        target.temperature = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n        break;\n      case 112: // Capacitance Raw Sensor Value 2bytes 0-65535\n        target.capacitanceFlood = {};\n        target.capacitanceFlood.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n        break;\n      case 113: // Capacitance Raw Sensor Value 2bytes 0-65535\n        target.capacitancePad = {};\n        target.capacitancePad.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n        break;\n      case 110:\n        target.swversion = {};\n        var number = ((bytes[pos++] << 24) | (bytes[pos++] << 16) | (bytes[pos++] << 8) | bytes[pos++]) >>> 0;\n        target.swversion.value = number.toString(16);\n        target.startUpCount = {};\n        target.startUpCount.value = bytes[pos++];\n        target.watchdogCount = {};\n        target.watchdogCount.value = bytes[pos++];\n        target.stackTxFailRebootCount = {};\n        target.stackTxFailRebootCount.value = bytes[pos++];\n        target.badConditionsCounter = {};\n        target.badConditionsCounter.value = bytes[pos++]\n        break;\n      case 114: // Capacitance Raw Sensor Value 2bytes 0-65535\n        target.capacitanceEnd = {};\n        target.capacitanceEnd.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n        break;\n    }\n  }\n  var decoded = {};\n  var pos = 0;\n  var type;\n  switch(port) {\n    case 1:\n      if(bytes.length < 2) {\n        decoded.error = 'Wrong length of RX package';\n        break;\n      }\n      decoded.historySeqNr = (bytes[pos++] << 8) | bytes[pos++];\n      decoded.prevHistSeqNr = decoded.historySeqNr;\n      while(pos < bytes.length) {\n        type = bytes[pos++];\n        if(type & 0x80)\n            decoded.prevHistSeqNr--;\n        decodeFrame(type, decoded);\n      }\n      break;\n    case 2:\n      var now = new Date();\n      decoded.history = {};\n      if(bytes.length < 2) {\n        decoded.history.error = 'Wrong length of RX package';\n        break;\n      }\n      var seqNr = (bytes[pos++] << 8) | bytes[pos++];\n      while(pos < bytes.length) {\n        decoded.history[seqNr] = {};\n        decoded.history.now = now.toUTCString();\n        var secondsAgo = (bytes[pos++] << 24) | (bytes[pos++] << 16) | (bytes[pos++] << 8) | bytes[pos++];\n        decoded.history[seqNr].timeStamp = new Date(now.getTime() - secondsAgo*1000).toUTCString();\n        type = bytes[pos++];\n        decodeFrame(type, decoded.history[seqNr]);\n        seqNr++;\n      }\n  }\n  return decoded;\n};\n"
    }
}

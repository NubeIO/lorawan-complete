{
    "deviceProfile": {
        "name": "ICT-MFR-L-OTAA",
        "macVersion": "1.0.2",
        "regParamsRevision": "B",
        "supportsJoin": true,
        "payloadCodec": "CUSTOM_JS",
        "payloadEncoderScript": "",
        "payloadDecoderScript": "// TTN Decoder - MFR-Node Demo for Mike Ross 09/04/2021\n\nfunction Bytes2Float32(bytes) {\n\tvar sign = (bytes & 0x80000000) ? -1 : 1;\n\tvar exponent = ((bytes >> 23) & 0xFF) - 127;\n\tvar significand = (bytes & ~(-1 << 23));\n\n\tif (exponent == 128)\n\t\treturn sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);\n\n\tif (exponent == -127) {\n\t\tif (significand === 0) return sign * 0.0;\n\t\texponent = -126;\n\t\tsignificand /= (1 << 22);\n\t} else significand = (significand | (1 << 23)) / (1 << 23);\n\n\treturn sign * significand * Math.pow(2, exponent);\n}\n\n// Decode decodes an array of bytes into an object.\n//\t- fPort contains the LoRaWAN fPort number\n//\t- bytes is an array of bytes, e.g. [225, 230, 255, 0]\n// The function must return an object, e.g. {\"temperature\": 22.5}\nfunction Decode(fPort, bytes, variables) {\n    var port = fPort;\n// function Decoder(bytes, port){\n\tbyte = 0;\n\theader = 0;\n\tvar decoded = {};\n\t\n\tif(port == 1){\n\t\tdecoded.header = bytes[byte++];\n\t\tif(decoded.header & 0x10){\n\t\t\tdecoded.sec = (bytes[byte++] << 24 | bytes[byte++] << 16| bytes[byte++] << 8 | bytes[byte++]);\n\t\t\tdecoded.batmv = (bytes[byte++] << 8 | bytes[byte++]);\n\t\t\tdecoded.solmv = (bytes[byte++] << 8 | bytes[byte++]);\n\t\t\tdecoded.charge = (bytes[byte] & 1);\n\t\t\tdecoded.fault = (bytes[byte++] & 2) >> 1;\n\t\t}\n\t\telse if(decoded.header & 0x20){\n\t\t\tdecoded.adc_ch1 = ((bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0);\n\t\t\tdecoded.adc_ch2 = ((bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0);\n\t\t\tdecoded.adc_ch3 = ((bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0);\n\t\t\tdecoded.adc_ch4 = ((bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0);\n\t\t\tdecoded.adc_ch1volts = (decoded.adc_ch1 / 1000000);\n\t\t\tdecoded.vsw1 = Math.round(((((0.8319 * decoded.adc_ch1volts)-0.0925) - (0.8034 * Math.pow(decoded.adc_ch1volts,2)) + (0.5535 * Math.pow(decoded.adc_ch1volts,3)))*100)*100)/100;\n\t\t}\n\t\telse if(decoded.header & 0x40){\n\t\t\tdecoded.counter_ch4 = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\t\tdecoded.counter_ch3 = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\t\tdecoded.counter_ch2 = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\t\tdecoded.counter_ch1 = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\t}\n\t\telse if(decoded.header & 0x80){\n\t\t\tdecoded.index = decoded.header & 0x0f;\n\n\t\t\tif(decoded.index === 0){\n\t\t\t\tdecoded.AirTemperature  = (Math.round(Bytes2Float32(bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++] << 0)*100)/100);\n\t\t\t\tdecoded.RelativeHumidity = (Math.round(Bytes2Float32(bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++] << 0)*100)/100);\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t}\n\telse if(port == 10){\n\t\tdecoded.type = \"DEVICE_INFO\";\n\t\tdecoded.product_id = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\tdecoded.batch_num = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t\tdecoded.software_version = (bytes[byte++] << 24 | bytes[byte++] << 16 | bytes[byte++] << 8 | bytes[byte++]) >>> 0;\n\t}\n\telse if(port == 100){\n\t\tdecoded = {\n\t\t\ttype: \"DOWNLINK_RESPONSE\",\n\t\t\tstr: String.fromCharCode.apply(String, bytes)\n\t\t};\n\t}\n\n\treturn decoded;\n}"
    }
}

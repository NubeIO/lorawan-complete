{
    "deviceProfile": {
        "name": "ICT-MFR-L-OTAA",
        "macVersion": "1.0.2",
        "regParamsRevision": "B",
        "supportsJoin": true,
        "payloadCodec": "CUSTOM_JS",
        "payloadEncoderScript": "",
        "payloadDecoderScript": "/* TTN MFR-Node-PayloadV2 Decoder Base\n\tIncludes Base Diagnostic, Analog, Digital and SDI Section\n*/\n\n// Structure Type Define, 'nested' or 'flat'\nvar TYPE = 'flat';\n\n/*Class Buffer\n\tPurpose: A psuedo buffer class for accessing packet data,\n\t\tallows for uniformity between decoder types\n*/\nfunction Buf(buf){this.pl=buf}\nBuf.prototype.readUInt8=function(ofs){return ((this.pl[ofs]<<24)>>>24)};\nBuf.prototype.readUInt16BE=function(ofs){return ((this.pl[ofs++]<<24|this.pl[ofs++]<<16)>>>16)};\nBuf.prototype.readUInt32BE=function(ofs){return ((this.pl[ofs++]<<24|this.pl[ofs++]<<16|this.pl[ofs++]<<8|this.pl[ofs++])>>>0)};\nBuf.prototype.readInt8=function(ofs){return ((this.pl[ofs]<<24)>>24)};\nBuf.prototype.readInt16BE=function(ofs){return ((this.pl[ofs++]<<24|this.pl[ofs++]<<16)>>16)};\nBuf.prototype.readInt32BE=function(ofs){return ((this.pl[ofs++]<<24|this.pl[ofs++]<<16|this.pl[ofs++]<<8|this.pl[ofs++])>>0)};\nBuf.prototype.readFloatBE=function(ofs){return B2Fl(this.readUInt32BE(ofs))};\nBuf.prototype.slice=function(s,e){return this.pl.slice(s,e)};\nBuf.prototype.length=function(){return this.pl.length};\n\n/*Function Bytes2Float32(bytes)\n\tPurpose: Decodes an array of bytes(len 4(32 bit) into a float.\n\tArgs:\tbytes - an array of bytes, 4 bytes long\n\tReturns: 32bit Float representation\n*/\nfunction B2Fl(b){\n  \tvar sign =((b>>24)>0x7F)?-1:1;\n\tvar exp=((b>>23)&0xFF)-127;\n\tvar sig=(b&~(-1<<23));\n\tif(exp==128) return sign*((sig)?Number.NaN:Number.POSITIVE_INFINITY);\n\tif(exp==-127){\n\t\tif(sig===0) return sign*0.0;\n\t\texp=-126;\n\t\tsig/=(1<<22);\n\t} else sig=(sig|(1<<23))/(1<<23);\n\treturn sign*sig*Math.pow(2,exp);}\n\n/*Function buildNested(a)\n\tPurpose: Takes an array and parses them into a clean and succinct object of nested parameter sets\n\tArgs: a - An array of arrays containing Parameter Sets\n\tReturns: An Object containing nested Parameter Sets\n*/\nfunction buildNested(a){\n\tvar exc=[\"main\",\"diagnostic\",\"downlink\",\"device_info\",\"unknown\"];\n\tvar ret=[];\n\tfor(var el in a){\n\t\tvar e=a[el];\n\t\tvar par={};\n\t\tpar['label']=e[0];\n\t\tpar['channelId']=e[1];\n\t\tpar['value']=e[2];\n\t\tif(e.length>3&&exc.indexOf(e[3])<0) par['source']=e[3];\n\t\tif(e.length>4) par['unit']=e[4];\n\t\tret.push(par);\n\t} return ret;}\n\n/*Function buildFlat(a)\n\tPurpose: Takes an array and parses them into a clean and succinct object of flat parameters\n\tArgs: a - An array of arrays containing Parameter Sets\n\tReturns: An Object containing nested Parameter Sets\n*/\nfunction buildFlat(a){\n\tvar exc=[\"main\",\"diagnostic\",\"downlink\",\"device_info\",\"unknown\"];\n\tvar ret={}\n\tfor(var el in a){\n\t\tvar e=a[el];\n\t\tvar label = '';\n\t\tif(e.length>4){\n\t\t\tlabel=(exc.indexOf(e[3])<0) ? (e[0]+e[1]+'-'+e[4]) : (e[0]+'-'+e[4]);\n\t\t} else{\n\t\t\tlabel=(exc.indexOf(e[3])<0) ? (e[0]+e[1]) : (e[0]);\n\t\t} ret[label]=e[2];\n\t} return ret;}\n\n//Function - Decode, Wraps the primary decoder function for Chirpstack\nfunction Decode(fPort, bytes){\n\tvar buf = new Buf(bytes);\n\tvar decoded = {}\n\tvar readingsArr = primaryDecoder(buf, fPort);\n\tif(TYPE == 'flat'){ decoded = buildFlat(readingsArr); }\n\telse decoded['data'] = buildNested(readingsArr);\n\t\n\treturn decoded;\n}\n\n//Function - parseDeviceMsg, Wraps the primary decoder function for NNNCo\nfunction parseDeviceMsg(buf, lMsg){\n\tvar p = lMsg.loraPort;\n\tvar readingArr = primaryDecoder(buf, p);\n\tvar readingList = buildNested(readingArr);\n\treturn readingList;\n}\n\n//Function - Decoder, Wraps the primary decoder function for TTNv3\nfunction Decoder(b, p){\n\tvar buf = new Buf(b);\n\tvar decoded = {};\n\tvar readingsArr = primaryDecoder(buf, p);\n\tif(TYPE == 'flat'){ decoded = buildFlat(readingsArr); }\n\telse decoded['data'] = buildNested(readingsArr);\n\t\n\treturn decoded;\n}\n\n/*Function primaryDecoder\n\tPurpose: Main Entry point of TTN Console Decoder\n\tArgs:\tbytes - An array of bytes from LoRaWan raw payload(Hex Represented)\n\t\t\tport - LoRaWan Port that the message came through(set by Definium firmware)\n\tReturns: decoded - An object with data fields as decoded parameter values\n*/\nfunction primaryDecoder(buf,p){\n\tvar arr = [];\n\tvar byte = 0;\n\n\t//Data Packet Recieved\n\tif(p == 1){\n\t\tvar src = \"main\";\n\t\tvar charge_fault = buf.readUInt8(byte);\n\t\tvar header = buf.readUInt8(byte=byte+1);\n\t\tbyte = 2;\n\t\t\n\t\tarr.push(['packet-type', 0, \"DATA_PACKET\", src]);\n\t\tarr.push([\"payload-version\", 0, +((charge_fault & 0xf0) >> 4), src]);\n\t\tarr.push([\"charging-state\", 0, +(charge_fault & 1), src]);\n\t\tarr.push([\"fault\", 0, +((charge_fault & 2) >> 1), src]);\n\t\tarr.push([\"header\", 0, +((((header / 16) >> 0) * 10) + (header % 16)), src]);\n\t\t\n\t\t//Diagnostics Packet\n\t\tif(header == 0x10){\n\t\t\tvar src = \"diagnostic\";\n\t\t\tarr.push([\"uptime\", 0, +(buf.readUInt32BE(byte)), src, \"s\"]);\n\t\t\tarr.push([\"battery-voltage\", 0, +((buf.readUInt16BE(byte = byte+4)/1000).toFixed(3)), src, \"V\"]);\n\t\t\tarr.push([\"solar-voltage\", 0, +((buf.readUInt16BE(byte = byte+2)/1000).toFixed(3)), src, \"V\"]);\n\t\t\tvar freq = +(buf.readUInt32BE(byte=byte+2));\n\t\t\tarr.push([\"frequency\", 0, freq, src, \"ns/pulse\"]);\n\t\t\t\n\t\t\t//Freq Eq\n\t\t\t\n\t\t}\n\t\t//Analog Packet\n\t\telse if(header == 0x20){\n\t\t\tvar src = \"adc\";\n\t\t\tvar ch1 = +(buf.readUInt32BE(byte));\n\t\t\tvar ch2 = +(buf.readUInt32BE(byte=byte+4));\n\t\t\tvar ch3 = +(buf.readUInt32BE(byte=byte+4));\n\t\t\tvar ch4 = +(buf.readUInt32BE(byte=byte+4));\n\t\t\t\n\t\t\tarr.push([\"voltage-adc\", 1, ch1, src, \"uV\"]);\n\t\t\tarr.push([\"voltage-adc\", 2, ch2, src, \"uV\"]);\n\t\t\tarr.push([\"voltage-adc\", 3, ch3, src, \"uV\"]);\n\t\t\tarr.push([\"voltage-adc\", 4, ch4, src, \"uV\"]);\n\t\t\t\n\t\t\t// MP406 Voltage ADC\n\t\t\tvar mp406_in = ch1;\n\t\t\tvar inV = (mp406_in/1000000);\n\t\t\t\n\t\t\tvar vsw = +(((((0.8319 * inV)-0.0925) - (0.8034 * Math.pow(inV,2)) + (0.5535 * Math.pow(inV,3)))*100).toFixed(3));\n\t\t\tarr.push([\"soil-moisture\", 0, vsw, src, \"%\"]);\n\t\t}\n\t\t//Digital Packet\n\t\telse if(header == 0x40){\n\t\t\tvar src = \"digital\";\n\t\t\tarr.push([\"digital-count\", 4, +(buf.readUInt32BE(byte)), src]);\n\t\t\tarr.push([\"digital-count\", 3, +(buf.readUInt32BE(byte=byte+4)), src]);\n\t\t\tarr.push([\"digital-count\", 2, +(buf.readUInt32BE(byte=byte+4)), src]);\n\t\t\tarr.push([\"digital-count\", 1, +(buf.readUInt32BE(byte=byte+4)), src]);\n\t\t}\n\t\t//SDI Packet\n\t\telse if(header & 0x80){\n\t\t\tvar src = \"main\";\n\t\t\tvar com = +(header & 0x0f);\n\t\t\tarr.push([\"command\", 0, com, src]);\n\t\t\t//SDI 0\n\t\t\tif(com === 0){\n\t\t\t\tvar src = \"sdi_\" + com.toString();\n\t\t\t\t// ATH-2S aM! aD0! 11\n\t\t\t\tarr.push([\"air-temperature\", 0, +(buf.readFloatBE(byte).toFixed(3)), src, \"C\"]);\n\t\t\t\tarr.push([\"relative-humidity\", 0, +(buf.readFloatBE(byte=byte+4).toFixed(3)), src, \"%\"]);\n\t\t\t}\n\t\t}\n\t} else if(p === 10){\n\t\t//Device Info Packet Recieved\n\t\tvar src = \"device_info\";\n\t\tarr.push([\"packet-type\", 0, \"DEVICE_INFO\", \"main\"]);\n\t\tarr.push([\"product-id\", 0, buf.readUInt32BE(byte), src]);\n\t\tarr.push([\"batch-number\", 0, buf.readUInt32BE(byte=byte+4), src]);\n\t\tarr.push([\"software-version\", 0, buf.readUInt32BE(byte=byte+4), src]);\n\t} else if(p === 100){\n\t\t//Downlink Response Packet Recieved\n\t\tarr.push([\"packet-type\", 0, \"DOWNLINK_RESPONSE\", \"main\"]);\n\t\tarr.push([\"downlink-response\", 0, String.fromCharCode.apply(String, buf.slice(0, buf.length)), \"downlink\"]);\n\t} else{\n\t\t// Unknown Response Recieved\n\t\tarr.push([\"packet-type\", 0, \"UNKNOWN_RESPONSE\", \"main\"]);\n\t\tarr.push([\"raw-payload\", 0, buf.slice(0, buf.length), \"unknown\"]);\n\t}\n\n\treturn arr;\n}"
    }
}
